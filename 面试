## 面试
### 一、mysql主从延迟

#### 诱因：

当master有大并发的更新操作，但是slave的里面读取binlog的线程仅有一个，当某个SQL在slave上执行的时间稍长或者某个SQL要进行缩表就会导致master的SQL大量积压，未被同步到从服务器，这就导致了主从不一致，也就是主从延迟。

1.从库性能差

2.从库查询量大

3.主库大事务事件(给一张有上千万条记录的表添加一个字段，这个过程持续了10分钟，10分钟后主库才会写入binlog，才会传入从库，从库就延迟了10分钟)

#### 解决方案：

1.master的安全性要求比较高，所以sync_binlog=1,innodb_flush_log_at_trx_commit=1,而slaver则不需要这么高的数据安全，完全可以讲sync_binlog设置为0，innodb_flushlog,innodb_flush_log_at_trx_commit也都可以设置为0来提高SQL执行效率，这个能很大程度提高效率。**另外就是使用更好的硬件设备作为slave。**

通过show slave status\G;进行查看Seconds_Behind_Master就是延迟时间。

2.主从放到同一个交换机网络下。

3.直接禁用slave端的binlog。

4.大事务则建一个新表再把数据手动迁移到新表里。

### 二、nginx"惊群"

#### 诱因：

在nginx服务器中，当接收到新的请求来时，如果多个工作进程或者线程同时被唤醒并竞争去处理这个请求，而实际上只有一个进程能够被成功处理，导致其他进程被唤醒但是没有获得处理权，导致性能浪费下降。

#### 解决方案：

1.调整服务器进程/线程数量。

2.采用io异步模型

3.使用互斥锁，第一个取到锁的进程会去处理新连接，而其他试图取锁的进程会被阻塞等取到锁的进程处理完。

4.采用异步I/O模型，应用程序进程I/O操作进行的通俗能够去处理其他任务，充分利用CPU资源。
